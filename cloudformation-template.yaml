AWSTemplateFormatVersion: '2010-09-09'
Description: 'Multitenant JSON Block Builder Infrastructure'

Parameters:
  Environment:
    Type: String
    Default: dev
    Description: Environment name
  DeploymentId:
    Type: String
    Default: v1
    Description: Unique identifier to force API redeploy (e.g., timestamp)
  DomainName:
    Type: String
    Default: blockforger.zanzalaz.com
    Description: Base domain name for tenants
  HostedZoneId:
    Type: String
    Default: Z21K43WUBUVF1T
    Description: Route 53 Hosted Zone ID for zanzalaz.com
  EC2KeyName:
    Type: String
    Default: Json-Blockbuilder-MVP-keypair
    Description: EC2 Key Pair name for SSH access
  MyVPC:
    Type: String
    Default: vpc-fc7ecc86
    Description: VPC ID
  OpenAIApiKey:
    Type: String
    NoEcho: true
    Description: OpenAI API Key for LLM schema generation
  GoogleClientId:
    Type: String
    NoEcho: true
    Description: Google OAuth 2.0 Client ID
  GoogleClientSecret:
    Type: String
    NoEcho: true
    Description: Google OAuth 2.0 Client Secret
  StripeSecretKey:
    Type: String
    NoEcho: true
    Description: Stripe Secret Key for billing integration
  StripeWebhookSecret:
    Type: String
    NoEcho: true
    Description: Stripe Webhook Secret for webhook verification
  StripeMeterId:
    Type: String
    Description: Stripe Meter ID for usage tracking
    Default: mtr_test_61TTLjC3TnG8OSpTT41GTDVN8BdufJNw
  ExistingS3BucketArn:
    Type: String
    Default: arn:aws:s3:::universal-frontend-720291373173-dev
    Description: ARN of existing S3 bucket for schemas and static files
  ExistingDynamoDBTableArn:
    Type: String
    Default: arn:aws:dynamodb:us-east-1:720291373173:table/frontend-users
    Description: ARN of existing DynamoDB table for user data
  ExistingBillingTableArn:
    Type: String
    Default: arn:aws:dynamodb:us-east-1:720291373173:table/billing-admins
    Description: ARN of existing DynamoDB table for billing administrators
  StripeInitialPaymentUrl:
    Type: String
    Description: Stripe initial payment URL for token packages
    Default: https://buy.stripe.com/test_28E14n7945li2ttcuQ8so02
  StripeCustomerPortalUrl:
    Type: String
    Description: Stripe Customer Portal URL
    Default: https://billing.stripe.com/p/login/test_00weVd50W8xu3xx8eA8so00
  StripeProductId:
    Type: String
    Description: Stripe Product ID
    Default: prod_TGV0TTpa3D6MJc
  ScaleUpThreshold:
    Type: Number
    Description: 'CPU threshold for scaling up'
    Default: 85
  ScaleDownThreshold:
    Type: Number
    Description: 'CPU threshold for scaling down'
    Default: 20
  PaymentEnforced:
    Type: String
    Description: 'Enforce payment requirements - return 402 errors when insufficient tokens (true/false)'
    Default: 'false'
    AllowedValues: ['true', 'false']

Resources:
  # DynamoDB Table for user management - using existing table
  # FrontendUsersTable: Referenced by ARN parameter ExistingDynamoDBTableArn

  # DynamoDB Table for billing administrators - using existing table
  # BillingAdministratorsTable: Referenced by ARN parameter ExistingBillingTableArn
      # Additional attributes will be added dynamically:
      # - token_balance (Number): Current token balance for the user
      # - last_payment_date (Number): Unix timestamp of last payment
      # - last_payment_amount (Number): Amount of last payment in cents
      # - total_tokens_purchased (Number): Total tokens purchased all time
      # - account_created_date (Number): Unix timestamp when account was created

  # DynamoDB Table for tenant-to-user mapping - using existing table with deletion protection
  # BillingUserFromTenantTable: billinguser-from-tenant-dev (managed outside CloudFormation)

  # S3 Buckets removed - using existing buckets that cannot be deleted
  # All S3 bucket management is handled outside this stack

  # CloudFront removed - not using it yet

  # IAM Role for Lambda
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'json-blockbuilder-lambda-role-${Environment}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !Ref ExistingDynamoDBTableArn
                  - !Sub '${ExistingDynamoDBTableArn}/index/UserEmailIndex'
                  - !Ref ExistingBillingTableArn
                  - !Sub '${ExistingBillingTableArn}/index/StripeCustomerIndex'
                  - 'arn:aws:dynamodb:us-east-1:720291373173:table/billinguser-from-tenant-dev'
                  - 'arn:aws:dynamodb:us-east-1:720291373173:table/billinguser-from-tenant-dev/index/UserEmailIndex'
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                  - s3:ListBucket
                Resource:
                  - 'arn:aws:s3:::universal-frontend-720291373173-dev/*'
                  - 'arn:aws:s3:::universal-frontend-720291373173-dev'
        - PolicyName: LambdaDeploymentAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                Resource:
                  - 'arn:aws:s3:::lambda-deployment-720291373173-dev/*'

  # IAM Role for Stripe Webhook Lambda
  StripeWebhookLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'stripe-webhook-lambda-role-${Environment}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
          - Effect: Allow
            Principal:
              Service: events.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: BillingDynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !Ref ExistingBillingTableArn
                  - !Sub '${ExistingBillingTableArn}/index/StripeCustomerIndex'
        - PolicyName: SQSAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                  - sqs:GetQueueAttributes
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueUrl
                Resource: !GetAtt StripeWebhookQueue.Arn

  # Lambda Function
  JsonBlockBuilderLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'json-blockbuilder-api-${Environment}'
      Runtime: python3.9
      Handler: lambda_function.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        S3Bucket: 'lambda-deployment-720291373173-dev'
        S3Key: 'lambda-deployment-dev.zip'
      Environment:
        Variables:
          BUCKET_NAME: 'universal-frontend-720291373173-dev'
          OPENAI_API_KEY: !Ref OpenAIApiKey
          GOOGLE_CLIENT_ID: !Ref GoogleClientId
          GOOGLE_CLIENT_SECRET: !Ref GoogleClientSecret
          STRIPE_SECRET_KEY: !Ref StripeSecretKey
          STRIPE_WEBHOOK_SECRET: !Ref StripeWebhookSecret
          STRIPE_METER_ID: !Ref StripeMeterId
          STRIPE_INITIAL_PAYMENT_URL: !Ref StripeInitialPaymentUrl
          STRIPE_CUSTOMER_PORTAL_URL: !Ref StripeCustomerPortalUrl
          STRIPE_PRODUCT_ID: !Ref StripeProductId
          PAYMENT_ENABLED: !Ref PaymentEnforced
      Timeout: 30

  # Stripe Webhook Processing Lambda Function
  StripeWebhookLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'stripe-webhook-processor-${Environment}'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt StripeWebhookLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          from decimal import Decimal
          
          # Initialize AWS clients
          dynamodb = boto3.resource('dynamodb')
          billing_table = dynamodb.Table('billing-admins')
          
          def lambda_handler(event, context):
              print("=" * 50)
              print("STRIPE WEBHOOK LAMBDA STARTED")
              print("=" * 50)
              print(f"Full event received: {json.dumps(event, indent=2)}")
              print(f"Event keys: {list(event.keys())}")
              
              try:
                  # Check if this is an SQS event (all events now come through SQS)
                  if 'Records' in event and len(event['Records']) > 0:
                      print("✅ SQS event detected")
                      return handle_sqs_event(event)
                  else:
                      print("❌ Not an SQS event")
                      print(f"Event keys: {list(event.keys())}")
                      return {'statusCode': 200, 'body': 'Event not from SQS'}

              except Exception as e:
                  print(f"💥 ERROR processing webhook: {str(e)}")
                  import traceback
                  print(f"Traceback: {traceback.format_exc()}")
                  return {'statusCode': 500, 'body': f'Error: {str(e)}'}
          
          def handle_sqs_event(event):
              """Handle SQS events from EventBridge"""
              print("=" * 30)
              print("HANDLING SQS EVENT FROM EVENTBRIDGE")
              print("=" * 30)
              
              try:
                  # Process each record in the SQS event
                  for record in event.get('Records', []):
                      print(f"Processing SQS record: {json.dumps(record, indent=2)}")
                      
                      # Extract the Stripe event from the SQS message body
                      if 'body' in record:
                          try:
                              # Parse the SQS message body (now contains EventBridge event directly)
                              eventbridge_event = json.loads(record['body'])
                              print(f"Parsed EventBridge event: {json.dumps(eventbridge_event, indent=2)}")
                              
                              # Extract the Stripe event from the EventBridge event detail
                              if 'detail' in eventbridge_event:
                                  stripe_event = eventbridge_event['detail']
                                  event_type = stripe_event.get('type')
                                  
                                  print(f"Processing Stripe event type: {event_type}")
                                  
                                  # Process the event based on type using existing handlers
                                  if event_type == 'checkout.session.completed':
                                      result = handle_checkout_completed(stripe_event)
                                      print(f"Checkout completed result: {result}")
                                  elif event_type == 'checkout.session.async_payment_succeeded':
                                      result = handle_checkout_succeeded(stripe_event)
                                      print(f"Checkout succeeded result: {result}")
                                  elif event_type == 'checkout.session.async_payment_failed':
                                      result = handle_checkout_failed(stripe_event)
                                      print(f"Checkout failed result: {result}")
                                  elif event_type == 'checkout.session.expired':
                                      result = handle_checkout_expired(stripe_event)
                                      print(f"Checkout expired result: {result}")
                                  else:
                                      print(f"Unhandled event type: {event_type}")
                              else:
                                  print("No detail section found in EventBridge event")
                                      
                          except json.JSONDecodeError as e:
                              print(f"Failed to parse SQS message body: {e}")
                              print(f"Raw message body: {record['body']}")
                      else:
                          print("No body found in SQS record")
                          
                  return {
                      'statusCode': 200,
                      'body': json.dumps({'message': 'SQS processing completed'})
                  }
                  
              except Exception as e:
                  print(f"Error processing SQS event: {str(e)}")
                  import traceback
                  print(f"Traceback: {traceback.format_exc()}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': 'SQS processing failed'})
                  }
          
          def handle_checkout_completed(stripe_event):
              """Handle successful checkout completion"""
              print("=" * 30)
              print("HANDLING CHECKOUT COMPLETED")
              print("=" * 30)
              
              try:
                  session = stripe_event['data']['object']
                  print(f"Session data: {json.dumps(session, indent=2)}")
                  
                  # Use amount_subtotal instead of amount_total
                  amount_subtotal = session.get('amount_subtotal', 0)  # Amount in cents
                  print(f"Amount subtotal: {amount_subtotal} cents")
                  
                  # Convert amount to tokens ($1 = 30,000 tokens)
                  tokens_purchased = (amount_subtotal // 100) * 30000  # $1 = 30,000 tokens
                  print(f"Tokens to credit: {tokens_purchased}")
                  
                  print(f"Processing payment for {tokens_purchased} tokens, amount: ${amount_subtotal/100}")
                  
                  # Get user email from customer_details.email (this is the correct field)
                  customer_details = session.get('customer_details', {})
                  print(f"Customer details: {json.dumps(customer_details, indent=2)}")
                  
                  user_email = customer_details.get('email')
                  print(f"User email extracted: {user_email}")
                  
                  if not user_email:
                      print("❌ ERROR: No customer email found in checkout session")
                      print(f"Full session data: {json.dumps(session, indent=2)}")
                      return {'statusCode': 400, 'body': 'No customer email found'}
                  
                  print(f"✅ Crediting {tokens_purchased} tokens to {user_email}")
                  
                  # Get customer ID, only set if not empty
                  customer_id = session.get('customer', '')
                  print(f"Stripe customer ID: {customer_id}")
                  
                  # Prepare DynamoDB update - only set stripe_customer_id if it's not empty
                  if customer_id:
                      update_expression = 'SET token_balance = if_not_exists(token_balance, :zero) + :tokens, total_tokens_purchased = if_not_exists(total_tokens_purchased, :zero) + :tokens, last_payment_date = :date, last_payment_amount = :amount, stripe_customer_id = :customer_id'
                      expression_values = {
                          ':tokens': Decimal(str(tokens_purchased)),
                          ':zero': Decimal('0'),
                          ':date': Decimal(str(stripe_event['created'])),
                          ':amount': Decimal(str(amount_subtotal)),
                          ':customer_id': customer_id
                      }
                  else:
                      update_expression = 'SET token_balance = if_not_exists(token_balance, :zero) + :tokens, total_tokens_purchased = if_not_exists(total_tokens_purchased, :zero) + :tokens, last_payment_date = :date, last_payment_amount = :amount'
                      expression_values = {
                          ':tokens': Decimal(str(tokens_purchased)),
                          ':zero': Decimal('0'),
                          ':date': Decimal(str(stripe_event['created'])),
                          ':amount': Decimal(str(amount_subtotal))
                      }
                  
                  print(f"Update expression: {update_expression}")
                  print(f"Expression values: {expression_values}")
                  
                  # Update user's token balance and payment history in billing-admins table
                  print("🔄 Updating DynamoDB...")
                  response = billing_table.update_item(
                      Key={'user_email': user_email},
                      UpdateExpression=update_expression,
                      ExpressionAttributeValues=expression_values,
                      ReturnValues='UPDATED_NEW'
                  )
                  
                  print(f"✅ DynamoDB update response: {json.dumps(response, indent=2, default=str)}")
                  print(f"✅ Successfully updated token balance for {user_email}")
                  return {'statusCode': 200, 'body': f'Tokens added successfully to {user_email}'}
                  
              except Exception as e:
                  print(f"💥 ERROR handling checkout completed: {str(e)}")
                  import traceback
                  print(f"Traceback: {traceback.format_exc()}")
                  return {'statusCode': 500, 'body': f'Error: {str(e)}'}
          
          def handle_checkout_succeeded(stripe_event):
              """Handle async payment success"""
              return handle_checkout_completed(stripe_event)
          
          def handle_checkout_failed(stripe_event):
              """Handle payment failure"""
              try:
                  session = stripe_event['data']['object']
                  customer_email = session.get('customer_details', {}).get('email')
                  
                  print(f"Payment failed for {customer_email}")
                  
                  # Could log failure or send notification
                  return {'statusCode': 200, 'body': 'Payment failure logged'}
                  
              except Exception as e:
                  print(f"Error handling checkout failed: {str(e)}")
                  return {'statusCode': 500, 'body': f'Error: {str(e)}'}
          
          def handle_checkout_expired(stripe_event):
              """Handle session expiration"""
              try:
                  session = stripe_event['data']['object']
                  customer_email = session.get('customer_details', {}).get('email')
                  
                  print(f"Checkout session expired for {customer_email}")
                  
                  # Could log expiration or send notification
                  return {'statusCode': 200, 'body': 'Session expiration logged'}
                  
              except Exception as e:
                  print(f"Error handling checkout expired: {str(e)}")
                  return {'statusCode': 500, 'body': f'Error: {str(e)}'}
      Environment:
        Variables:
          # No Stripe API key needed - we only process EventBridge events
          ENVIRONMENT: !Ref Environment
      Timeout: 30

  # API Gateway
  ApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub 'json-blockbuilder-api-${Environment}'
      Description: API Gateway for JSON Block Builder Lambda

  # Global Gateway Responses to add CORS headers on errors
  ApiGatewayResponseDefault4XX:
    Type: AWS::ApiGateway::GatewayResponse
    Properties:
      RestApiId: !Ref ApiGateway
      ResponseType: DEFAULT_4XX
      ResponseParameters:
        gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
        gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
        gatewayresponse.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS,PUT,DELETE'"

  ApiGatewayResponseDefault5XX:
    Type: AWS::ApiGateway::GatewayResponse
    Properties:
      RestApiId: !Ref ApiGateway
      ResponseType: DEFAULT_5XX
      ResponseParameters:
        gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
        gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
        gatewayresponse.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS,PUT,DELETE'"

  ApiGatewayResponseUnauthorized:
    Type: AWS::ApiGateway::GatewayResponse
    Properties:
      RestApiId: !Ref ApiGateway
      ResponseType: UNAUTHORIZED
      ResponseParameters:
        gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
        gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
        gatewayresponse.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS,PUT,DELETE'"

  ApiGatewayResponseAccessDenied:
    Type: AWS::ApiGateway::GatewayResponse
    Properties:
      RestApiId: !Ref ApiGateway
      ResponseType: ACCESS_DENIED
      ResponseParameters:
        gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
        gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
        gatewayresponse.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS,PUT,DELETE'"

  ApiGatewayResponseMissingAuthToken:
    Type: AWS::ApiGateway::GatewayResponse
    Properties:
      RestApiId: !Ref ApiGateway
      ResponseType: MISSING_AUTHENTICATION_TOKEN
      ResponseParameters:
        gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
        gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
        gatewayresponse.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS,PUT,DELETE'"

  ApiGatewayResourceApi:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: 'api'

  # API Gateway Authorizer
  ApiGatewayAuthorizer:
    Type: AWS::ApiGateway::Authorizer
    Properties:
      RestApiId: !Ref ApiGateway
      Name: JsonBlockBuilderAuthorizer
      Type: REQUEST
      AuthorizerUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
      AuthorizerResultTtlInSeconds: 300
      IdentitySource: method.request.header.Authorization

  # ----------- Child Resources -----------
  ApiGatewayResourceDel:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'del'

  ApiGatewayResourceJson:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'json'

  ApiGatewayResourceAuth:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'auth'

  ApiGatewayResourceLlm:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'llm'

  ApiGatewayResourceLlmPreload:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'llm-preload'

  ApiGatewayResourceRegister:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'register'

  ApiGatewayResourceDeleteTenant:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'admin_delete'

  ApiGatewayResourceCreateUser:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'create_user'

  ApiGatewayResourceManageOAuthScopes:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'manage_oauth_scopes'

  ApiGatewayResourceOAuthTokenExchange:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'oauth_token_exchange'

  ApiGatewayResourceCreateAccountLink:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'create_account_link'

  ApiGatewayResourceCheckAccountStatus:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'check_account_status'

  ApiGatewayResourceBill:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'bill'

  ApiGatewayResourceDebitTokens:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'debit_tokens'

  # ----------- Methods -----------
  ApiMethodApiOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceApi
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true
  ApiMethodDel:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceDel
      HttpMethod: POST
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref ApiGatewayAuthorizer
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "del",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
      MethodResponses:
        - StatusCode: 200

  ApiMethodJson:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceJson
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "json",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodJsonOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceJson
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  ApiMethodAuth:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceAuth
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "auth",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodAuthOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceAuth
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  ApiMethodLlm:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceLlm
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "llm",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodLlmOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceLlm
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  ApiMethodLlmPreload:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceLlmPreload
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "llm-preload",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodLlmPreloadOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceLlmPreload
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  ApiMethodRegister:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceRegister
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "register",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodRegisterOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceRegister
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  ApiMethodDeleteTenant:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceDeleteTenant
      HttpMethod: POST
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref ApiGatewayAuthorizer
      Integration:
        Type: AWS
        Credentials: !GetAtt ApiGatewayExecutionRole.Arn
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "admin_delete",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
      MethodResponses:
        - StatusCode: 200

  ApiMethodCreateUser:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceCreateUser
      HttpMethod: POST
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref ApiGatewayAuthorizer
      Integration:
        Type: AWS
        Credentials: !GetAtt ApiGatewayExecutionRole.Arn
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "create_user",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
      MethodResponses:
        - StatusCode: 200

  ApiMethodManageOAuthScopes:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceManageOAuthScopes
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "manage_oauth_scopes",
              "body": $input.json('$.body'),
              "headers": {
                #foreach($header in $input.params().header.keySet())
                "$header": "$util.escapeJavaScript($input.params().header.get($header))"#if($foreach.hasNext),#end
                #end
              }
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodManageOAuthScopesOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceManageOAuthScopes
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  ApiMethodOAuthTokenExchange:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceOAuthTokenExchange
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "oauth_token_exchange",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodOAuthTokenExchangeOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceOAuthTokenExchange
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  # Create Account Link Method
  ApiMethodCreateAccountLink:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceCreateAccountLink
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "create_account_link",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodCreateAccountLinkOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceCreateAccountLink
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  # Check Account Status Method
  ApiMethodCheckAccountStatus:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceCheckAccountStatus
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "check_account_status",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodCheckAccountStatusOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceCheckAccountStatus
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  # Bill Method (for daily billing process)
  ApiMethodBill:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceBill
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "bill",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodBillOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceBill
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  # Debit Tokens Method
  ApiMethodDebitTokens:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceDebitTokens
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "debit_tokens",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodDebitTokensOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceDebitTokens
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  # REMOVED: ApiMethodSignupCallback - now handled via auth endpoint with billing field
  # REMOVED: ApiMethodSignupCallbackOptions - now handled via auth endpoint with billing field
  # REMOVED: ApiMethodBillingConfig - now using direct Stripe portal redirects
  # REMOVED: ApiMethodBillingConfigOptions - now using direct Stripe portal redirects

  # REMOVED: ApiMethodCheckPermissions - billing permission now handled in auth endpoint

  # REMOVED: ApiMethodCheckPermissionsOptions - billing permission now handled in auth endpoint


  # ----------- Deployment -----------
  ApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - ApiMethodApiOptions
      - ApiMethodDel
      - ApiMethodJson
      - ApiMethodJsonOptions
      - ApiMethodAuth
      - ApiMethodAuthOptions
      - ApiMethodLlm
      - ApiMethodLlmOptions
      - ApiMethodLlmPreload
      - ApiMethodLlmPreloadOptions
      - ApiMethodRegister
      - ApiMethodRegisterOptions
      - ApiMethodDeleteTenant
      - ApiMethodCreateUser
      - ApiMethodManageOAuthScopes
      - ApiMethodManageOAuthScopesOptions
      - ApiMethodOAuthTokenExchange
      - ApiMethodOAuthTokenExchangeOptions
      - ApiMethodCreateAccountLink
      - ApiMethodCreateAccountLinkOptions
      - ApiMethodCheckAccountStatus
      - ApiMethodCheckAccountStatusOptions
      - ApiMethodBill
      - ApiMethodBillOptions
      - ApiMethodDebitTokens
      - ApiMethodDebitTokensOptions
    Properties:
      RestApiId: !Ref ApiGateway
      StageName: !Ref Environment
      Description: !Sub 'Deployment ${AWS::StackName} - ${AWS::Region} - ${DeploymentId}'

  # Lambda Permission for API Gateway
  LambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref JsonBlockBuilderLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*'

  # EC2 Instance Role
  EC2InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'json-blockbuilder-ec2-role-${Environment}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess
      Policies:
        - PolicyName: S3SchemaAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                  - s3:ListBucket
                Resource:
                  - 'arn:aws:s3:::universal-frontend-720291373173-dev/schemas/*'
                  - 'arn:aws:s3:::universal-frontend-720291373173-dev/cache/*'
                  - 'arn:aws:s3:::universal-frontend-720291373173-dev'
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !Ref ExistingDynamoDBTableArn
                  - !Sub '${ExistingDynamoDBTableArn}/index/UserEmailIndex'
                  - !Ref ExistingBillingTableArn
                  - !Sub '${ExistingBillingTableArn}/index/StripeCustomerIndex'
                  - 'arn:aws:dynamodb:us-east-1:720291373173:table/billinguser-from-tenant-dev'
                  - 'arn:aws:dynamodb:us-east-1:720291373173:table/billinguser-from-tenant-dev/index/UserEmailIndex'

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref EC2InstanceRole

  # Security Group for EC2
  EC2SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for JSON Block Builder EC2 instance
      VpcId: !Ref MyVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 8080
          ToPort: 8080
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 3030
          ToPort: 3030
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0

  # Auto Scaling Group Resources
  # Use existing subnets from parameters

  # Load Balancer Security Group
  LoadBalancerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable HTTP and HTTPS access to the Load Balancer
      VpcId: !Ref MyVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 3030
          ToPort: 3030
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0

  # Application Load Balancer
  ApplicationLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub '${AWS::StackName}-ALB'
      Scheme: internet-facing
      Type: application
      Subnets:
        - subnet-02ae9848
        - subnet-9cf794c0
      SecurityGroups:
        - !Ref LoadBalancerSecurityGroup
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-ALB'

  # Target Group (Port 8080)
  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub '${AWS::StackName}-TargetGroup'
      Port: 8080
      Protocol: HTTP
      VpcId: !Ref MyVPC
      HealthCheckIntervalSeconds: 30
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 10
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 2
      TargetType: instance
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-TargetGroup'

  # Target Group (Port 3030 - Petstore)
  TargetGroupPetstore:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub '${AWS::StackName}-TargetGroupPetstore'
      Port: 3030
      Protocol: HTTP
      VpcId: !Ref MyVPC
      HealthCheckIntervalSeconds: 30
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 10
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 2
      TargetType: instance
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-TargetGroupPetstore'

  # SSL Certificate for HTTPS
  SSLCertificate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Ref DomainName
      SubjectAlternativeNames:
        - !Sub '*.${DomainName}'
      ValidationMethod: DNS
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-SSL-Certificate'

  # DNS Record for blockforger.zanzalaz.com pointing to ALB
  BlockforgerDNSRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Ref DomainName
      Type: CNAME
      TTL: 300
      ResourceRecords:
        - !GetAtt ApplicationLoadBalancer.DNSName

  # HTTPS Load Balancer Listener (Port 443 -> Target 8080)
  LoadBalancerListenerHTTPS:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref TargetGroup
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 443
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref SSLCertificate
      SslPolicy: ELBSecurityPolicy-TLS-1-2-2017-01

  # HTTPS Load Balancer Listener (Port 3030 -> Target 3030 - Petstore)
  LoadBalancerListenerHTTPSPetstore:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref TargetGroupPetstore
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 3030
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref SSLCertificate
      SslPolicy: ELBSecurityPolicy-TLS-1-2-2017-01

  # HTTP Load Balancer Listener (Port 80 -> Target 8080)
  LoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref TargetGroup
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 80
      Protocol: HTTP

  # Launch Template
  LaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub '${AWS::StackName}-LaunchTemplate'
      LaunchTemplateData:
        ImageId: ami-0a7d80731ae1b2435  # Ubuntu 22.04 LTS AMI in us-east-1
        InstanceType: t3.micro
        KeyName: !Ref EC2KeyName
        IamInstanceProfile:
          Arn: !GetAtt EC2InstanceProfile.Arn
        SecurityGroupIds:
          - !Ref EC2SecurityGroup
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash
            apt update -y
            
            # Install Docker
            apt install -y apt-transport-https ca-certificates curl software-properties-common
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
            add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
            apt update -y
            apt install -y docker-ce docker-ce-cli containerd.io
            systemctl start docker
            systemctl enable docker
            
            # Install Node.js 18.x (Ubuntu has modern glibc)
            curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
            apt install -y nodejs
            
            # Verify installation
            node --version
            npm --version
            npm install -g forever
            
            # Clone the repository
            git clone https://github.com/markd315/JSON-blockbuilder-frontend.git /opt/json-blockbuilder
            
            cd /opt/json-blockbuilder
            npm install
            
            # Start the application with forever using npm start
            forever start -c "npm start" ./
            
            # Pull and run Swagger Petstore on port 3030
            docker pull swaggerapi/petstore
            docker run -d --name petstore \
              -e SWAGGER_HOST=http://petstore.swagger.io \
              -e SWAGGER_URL=http://localhost \
              -e SWAGGER_BASE_PATH=/v2 \
              -p 3030:8080 \
              --restart unless-stopped \
              swaggerapi/petstore
            
            # Create a startup script
            cat > /etc/systemd/system/json-blockbuilder.service << EOF
            [Unit]
            Description=JSON Block Builder Application
            After=network.target
            
            [Service]
            Type=simple
            User=ubuntu
            WorkingDirectory=/opt/json-blockbuilder
            ExecStart=/usr/bin/forever start -c "npm start" ./
            Restart=always
            Environment=AWS_REGION=us-east-1
            Environment=S3_BUCKET_NAME=universal-frontend-720291373173-dev
            Environment=STRIPE_INITIAL_PAYMENT_URL=${StripeInitialPaymentUrl}
            Environment=STRIPE_CUSTOMER_PORTAL_URL=${StripeCustomerPortalUrl}
            Environment=PAYMENT_ENABLED=${PaymentEnforced}
            
            [Install]
            WantedBy=multi-user.target
            EOF
            
            systemctl enable json-blockbuilder.service
            systemctl start json-blockbuilder.service
        TagSpecifications:
          - ResourceType: instance
            Tags:
              - Key: Name
                Value: !Sub '${AWS::StackName}-Instance'

  # Auto Scaling Group
  AutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      AutoScalingGroupName: !Sub '${AWS::StackName}-ASG'
      VPCZoneIdentifier:
        - subnet-02ae9848
        - subnet-9cf794c0
      LaunchTemplate:
        LaunchTemplateId: !Ref LaunchTemplate
        Version: !GetAtt LaunchTemplate.LatestVersionNumber
      MinSize: 1
      MaxSize: 10
      DesiredCapacity: 1
      TargetGroupARNs:
        - !Ref TargetGroup
        - !Ref TargetGroupPetstore
      HealthCheckType: ELB
      HealthCheckGracePeriod: 300
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-ASG-Instance'
          PropagateAtLaunch: true

  # CloudWatch Alarms for Auto Scaling
  CPUUtilizationAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: "Scale up if CPU utilization is high"
      MetricName: CPUUtilization
      Namespace: AWS/EC2
      Statistic: Average
      Period: 300
      EvaluationPeriods: 2
      Threshold: !Ref ScaleUpThreshold
      ComparisonOperator: GreaterThanOrEqualToThreshold
      AlarmActions:
        - !Ref ScaleUpPolicy
      Dimensions:
        - Name: AutoScalingGroupName
          Value: !Ref AutoScalingGroup

  ScaleUpPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AdjustmentType: ChangeInCapacity
      AutoScalingGroupName: !Ref AutoScalingGroup
      Cooldown: 300
      ScalingAdjustment: 1

  ScaleDownPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AdjustmentType: ChangeInCapacity
      AutoScalingGroupName: !Ref AutoScalingGroup
      Cooldown: 300
      ScalingAdjustment: -1

  LowCPUUtilizationAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: "Scale down if CPU utilization is low"
      MetricName: CPUUtilization
      Namespace: AWS/EC2
      Statistic: Average
      Period: 300
      EvaluationPeriods: 2
      Threshold: !Ref ScaleDownThreshold
      ComparisonOperator: LessThanOrEqualToThreshold
      AlarmActions:
        - !Ref ScaleDownPolicy
      Dimensions:
        - Name: AutoScalingGroupName
          Value: !Ref AutoScalingGroup

  ApiGatewayExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: ApiGatewayInvokeLambda
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource: !GetAtt JsonBlockBuilderLambda.Arn

  # EventBridge Rule for daily billing at midnight Eastern
  DailyBillingRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub '${AWS::StackName}-daily-billing'
      Description: 'Trigger daily billing process at midnight Eastern Time'
      ScheduleExpression: 'cron(0 5 * * ? *)'  # 5 AM UTC = midnight Eastern
      State: ENABLED
      Targets:
        - Arn: !GetAtt JsonBlockBuilderLambda.Arn
          Id: 'DailyBillingTarget'
          Input: '{"type": "bill"}'

  # Permission for EventBridge to invoke Lambda
  EventBridgeLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref JsonBlockBuilderLambda
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt DailyBillingRule.Arn

  # SQS Queue for Stripe webhook events (now the main processing queue)
  StripeWebhookQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub 'stripe-webhook-queue-${Environment}'
      MessageRetentionPeriod: 1209600  # 14 days
      VisibilityTimeout: 30

  # EventBridge Rule for Stripe webhook events - now routes to SQS instead of Lambda
  StripeRule:
    Type: AWS::Events::Rule
    Properties:
      Name: Stripe-Rule
      EventPattern: >-
        {"source":[{"prefix":"aws.partner/stripe.com"}],"detail-type":["checkout.session.completed"]}
      State: ENABLED
      Description: ''
      EventBusName: !Sub 'arn:aws:events:${AWS::Region}:${AWS::AccountId}:event-bus/aws.partner/stripe.com/ed_test_61TTWBLDLBl1c14x516TTKeNBlSQg1FcYBVxZwQS89Ci'
      Targets:
        - Id: StripeSQSTarget
          Arn: !GetAtt StripeWebhookQueue.Arn

  # REMOVED: StripeWebhookLambdaPermission - EventBridge now routes to SQS instead of Lambda directly 

  # Permission for EventBridge to send messages to SQS Queue
  StripeWebhookQueuePolicy:
    Type: AWS::SQS::QueuePolicy
    Properties:
      Queues:
        - !Ref StripeWebhookQueue
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: events.amazonaws.com
            Action: sqs:SendMessage
            Resource: !GetAtt StripeWebhookQueue.Arn

  # SQS Event Source Mapping for Queue to StripeWebhookLambda
  StripeQueueEventSourceMapping:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      EventSourceArn: !GetAtt StripeWebhookQueue.Arn
      FunctionName: !Ref StripeWebhookLambda
      BatchSize: 1
      MaximumBatchingWindowInSeconds: 0

Outputs:
  ApiGatewayUrl:
    Description: API Gateway URL
    Value: !Sub 'https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/${Environment}/api'
  
  S3BucketName:
    Description: S3 Bucket for schemas (existing)
    Value: !Ref ExistingS3BucketArn
  
  
  DynamoDBTableName:
    Description: DynamoDB Table Name
    Value: !Ref ExistingDynamoDBTableArn
  
  LambdaDeploymentBucketName:
    Description: S3 Bucket for Lambda deployment package
    Value: 'lambda-deployment-720291373173-dev'

  # CloudFront outputs removed - not using it yet

  # StaticContentBucketName removed - bucket not managed by this stack

  ApplicationLoadBalancerDNS:
    Description: Application Load Balancer DNS Name
    Value: !GetAtt ApplicationLoadBalancer.DNSName

  ApplicationLoadBalancerHTTPSURL:
    Description: Application Load Balancer HTTPS URL
    Value: !Sub 'https://${ApplicationLoadBalancer.DNSName}'

  SSLCertificateArn:
    Description: SSL Certificate ARN
    Value: !Ref SSLCertificate

  AutoScalingGroupName:
    Description: Auto Scaling Group Name
    Value: !Ref AutoScalingGroup 
