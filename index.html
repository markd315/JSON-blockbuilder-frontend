<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>A Blockly-based visual editor for JSON structures.</title>

    <script type="text/javascript" src="blockly_compressed.js"></script>
    <!-- context menu in English: -->
    <script type="text/javascript" src="msg/js/en.js"></script>

    <!-- a simple yet very practical widget: -->
    <script type="text/javascript" src="field_textbutton.js"></script>

    <!-- override/extend some Blockly code (menu-based building code): -->
    <script type="text/javascript" src="menuly_override.js"></script>

    <!-- blocks to build JSON structures from: -->
    <script type="text/javascript" src="menuly_blocks.js"></script>

    <!-- transforming a blockly diagram into a JSON string: -->
    <script type="text/javascript" src="menuly_codegen.js"></script>

    <!-- building a blockly diagram from a JSON string: -->
    <script type="text/javascript" src="menuly_2blocks.js"></script>

    <!-- Clientsided javascript cannot loop over a folder so all schemas must be individualy registered in dom-->


    <script>
        var serverConfig = {};
        var accessToken = undefined;
        var schema = {};
        function loadJsonForRequest(name){
            let xhttp = new XMLHttpRequest();
            xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                var tmp = JSON.parse(this.responseText);
                schema[name] = tmp;
            }
            };
            xhttp.open("GET", 'http://localhost:8888/schema/' + name + ".json", false);
            xhttp.send();
        }

        function loadConfig(name){
            let xhttp = new XMLHttpRequest();
            xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                serverConfig = JSON.parse(this.responseText);
                getToken(serverConfig);
            }
            };
            xhttp.open("GET", 'http://localhost:8888/serverConfig.json', true);
            xhttp.send();
        }

        function getToken(serverConfig){
            let xhttp = new XMLHttpRequest();
            xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                accessToken = JSON.parse(this.responseText)['access_token'];
            }
            };
            xhttp.open("POST", serverConfig.authorizationServer, true);
            xhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            xhttp.send("grant_type=client_credentials&client_id=" + serverConfig.client_id + "&client_secret=" + serverConfig.client_secret);
            return accessToken;
        }

        loadConfig();


        var idsFromChildren = {};

        function childBlockFromBlock(property, sendingBlock){
            for(var idx in sendingBlock.inputList){
                if(sendingBlock.inputList[idx].fieldRow[0].text_ == property){ //for required fields
                    return sendingBlock.inputList[idx].connection.targetConnection.sourceBlock_;
                }
                if(sendingBlock.inputList[idx].fieldRow[1].text_ == property){ //for optional fields (-) precedes
                    return sendingBlock.inputList[idx].connection.targetConnection.sourceBlock_;
                }
                //use input.conection when we find

            }
        }

        function childFirstBodyIdStrategy(sendingBlock, topLevelSchema){
            for(var propertyName in topLevelSchema.properties){
                let property = topLevelSchema.properties[propertyName];
                if(property.apiCreationStrategy == 'childFirstBodyId' && property['$ref'] != undefined){
                    let block = childBlockFromBlock(propertyName, sendingBlock);
                    var type = block.type;
                    if(schema[type] == undefined){ //make sure we have schema ready.
                        loadJsonForRequest(type);
                    }
                    childFirstBodyIdStrategy(block, type);
                    let obj = Blockly.JSON.generalBlockToObj(block);
                    sendSingleRequest(JSON.stringify(obj), type, propertyName);
                }
            }
        }

        function parentFirstRouteIdStrategy(sendingBlock, topLevelSchema, rootType){
            //TODO don't send these fields in the parent create body
        }

        function pullUpIdsFromChildren(obj, idsFromChildren){
            var tmpJson = JSON.parse(obj);
            for(let childField in idsFromChildren){
                if(tmpJson[childField] != undefined){
                    tmpJson[childField] = idsFromChildren[childField];
                }
            }
            return JSON.stringify(tmpJson);
        }

        function sendSingleRequest(obj, type, propertyOrParent){ //if last param undefined, this is a parent request.
            if(schema[type].endpoint != undefined){
                console.log("Detected an overridden endpoint mapping");
                type = schema[type].endpoint;
            }
            let xhttp = new XMLHttpRequest();
            let fullRoute = serverConfig.baseUrl + "/" + type;
            xhttp.onreadystatechange = function() {
                if (this.readyState == 4) {
                    if(propertyOrParent == undefined){ //root request
                        document.getElementById('response_area').value = "status: " + this.status + "\nresponse: " + this.responseText;
                    }
                    else{
                        //TODO remove server mocking on next line, use `this.responseText` for mocked
                        let mocked = "{\"id\": \"2f02372d-a590-4c4b-b3e2-c070025a3b8e\"}";
                        idsFromChildren[propertyOrParent] = JSON.parse(mocked)['id'];
                        //idsFromChildren[propertyOrParent] = JSON.parse(this.responseText)['id'];
                    }
                }
            };
            if(serverConfig.authType == "basic"){
                xhttp.open("POST", fullRoute, false, serverConfig.user, serverConfig.pass);
                xhttp.setRequestHeader("Authorization", btoa(unescape(encodeURIComponent(serverConfig.user + ":" + serverConfig.pass))));
            }
            else if(serverConfig.authType == "client_credentials"){
                if(accessToken == undefined){
                    getToken(serverConfig);
                }
                xhttp.open("POST", fullRoute, false);
                xhttp.setRequestHeader("Authorization", accessToken);
            }
            else{
                console.log("Invalid authtype configured, inferring none");
                xhttp.open("POST", fullRoute, false);
            }
            xhttp.setRequestHeader("Content-type", "application/json");
            let finalObj = pullUpIdsFromChildren(obj, idsFromChildren);
            xhttp.send(finalObj);
            //TODO parentFirstRouteIdStrategy() implementation;
        }

        function sendRequests() {
            let payload = document.getElementById('json_area').value;
            let topBlocks = Blockly.getMainWorkspace().getTopBlocks(false);
            let sendingBlock = topBlocks[0].childBlocks_[0];
            if(serverConfig == {}){
                loadConfig();
            }
            var rootType = sendingBlock.type;
            if(schema[rootType] == undefined){
                loadJsonForRequest(sendingBlock.type);
            }
            childFirstBodyIdStrategy(sendingBlock, schema[rootType]);
            sendSingleRequest(payload, rootType, undefined);
        }

        function updateJSONarea() {
            document.getElementById('json_area').value = Blockly.JSON.fromWorkspace( Blockly.getMainWorkspace() );
        }

        function interpretJSONarea() {
            Blockly.JSON.toWorkspace( document.getElementById('json_area').value, Blockly.getMainWorkspace() );
        }

    </script>
    <style>
        body {
            background-color: #fff;
            font-family: Times New roman;
        }
        h1 {
            font-weight: normal;
            font-size: 140%;
            padding-left: 500px;
        }
    </style>
</head>
<body>

<!--<h1>Built complex rules authomatically by <a href=http://jsonlogic.com/>JsonLogic editor</a> utilizing <a href="https://developers.google.com/blockly/">Blockly</a></h1>-->

  <br/>

  <div style="height: 800px">
    <div id="blocklyDiv" style="float: left; width: 74%; height: 100%"></div>

    <xml id="toolbox" style="display: none">

        <category name="Input" colour="210" >
            <block type="var"></block>
            <block type="dictionary"></block>
            <block type="array"></block>
            <block type="number"></block>
            <block type="string"></block>
            <block type= "true_false"></block>
        </category>
       
        <category name="Logic" colour="120">
            <block type= "if_logic"></block>
            <block type= "logical"></block>
            <block type= "not"></block>

        </category>
        <category name="Boolean" colour="290">
            <block type= "boolean"></block>
        </category>

        <category name="Numeric" colour="150">
            <block type= "comparison"></block>
            <block type= "minmax"></block>
            <block type= "between"></block>
            <block type= "arithmatic"></block>
        </category>

        <category name="Array" colour="330">
            <block type= "map_filter"></block>
            <block type= "merge"></block>
            <block type= "InMiss"></block>
        </category>

        <category name="String" colour="20">
            <block type="inString"></block>
            <block type="catString"></block>
            <block type="subStr"></block>
            <block type="log"></block>
        </category>

        <category name="Custom" colour="20">
            <block type="product"></block>
            <block type="latlong"></block>
            <block type="employee"></block>
        </category>
        <!---->
        

    </xml>

    <div style="margin-left: 74%; width: 24%; height: 100%">
        <button onclick='interpretJSONarea()'>interpret JSON from the textarea below</button>
        <button onclick='sendRequests()'>POST</button>
        <textarea id=json_area style="height: 95%; width: 100%"></textarea>
        <textarea id=response_area style="height: 95%; width: 100%"></textarea>
    </div>
  </div>

  <script>

	Blockly.inject(document.getElementById('blocklyDiv'), {
        //rtl: true,
        toolbox: document.getElementById('toolbox'),
        media: 'media/',    // to avoid reaching to the web for icons
		sound: false,
		collapse: true, comments: true, disable: false, scrollbars: true, trashcan: true // those ones are automatically true when there are categories
	});

    Blockly.JSON.toWorkspace( 'null', Blockly.getMainWorkspace() );

    Blockly.addChangeListener(updateJSONarea);
  </script>
</body>
</html>

